<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringMVC Controllers 说明文档]]></title>
    <url>%2F2018%2F01%2F05%2FSpringMVC-Controllers-%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[翻译自官方文档，并加上了自己的理解，解释更加直白。 官方文档地址：Spring Web MVC 1 Declaration使用@Controller注解标记一个类，这个类就是一个SpringMVC Controller对象。 123456789@Controllerpublic class HelloController &#123; @GetMapping("/hello") public String handle(Model model) &#123; model.addAttribute("message", "Hello World!"); return "index"; &#125;&#125; 在XML文件进行配置，告诉Spring应该到哪里去找Controller控制器，加上如下一行，base-package 即controller所在位置 1&lt;context:component-scan base-package="org.example.web"/&gt; 完整XML配置文件 12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;context:component-scan base-package="org.example.web"/&gt; &lt;!-- ... --&gt;&lt;/beans&gt; 2 Request Mapping@RequestMapping 注解用于映射Request请求与与controller的处理方法。该注解有多个参数可以配置Request请求的属性，如URL，HTTP method，request parameters，headers，media types。 @RequestMapping 可以用于类也可以用于类方法。当@RequestMapping 标记在Controller 类上的时候，里面使用@RequestMapping 标记的方法的请求地址都是相对于类上的@RequestMapping 而言的；当Controller 类上没有标记@RequestMapping 注解时，方法上的@RequestMapping 都是绝对路径。最终路径都是相对于跟路径”/“的。通过这种组合的方法可以限制Request的匹配。 在SpringMVC 4.3 引入了组合注解来简化@RequestMapping的写法。 @GetMapping @PostMapping @PutMapping @DeleteMapping @PatchMapping 如@GetMapping等价于@RequestMapping(method = RequestMethod.GET)，组合注解通常用于method上，如下 123456789101112131415@RestController@RequestMapping("/persons")class PersonController &#123; @GetMapping("/&#123;id&#125;") public Person getPerson(@PathVariable Long id) &#123; // ... &#125; @PostMapping @ResponseStatus(HttpStatus.CREATED) public void add(@RequestBody Person person) &#123; // ... &#125;&#125; 2.1 URI patterns我们可以使用通配符去匹配request ?匹配一个字符 *匹配一个路径段中的零个或多个字符 **匹配零个或多个路径段 可以使用@PathVariable来声明URI变量并获取其值: 1234@GetMapping("/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;")public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) &#123; // ...&#125; URI变量即可以在类层级声明，也可以在方法层级声明: 123456789@Controller@RequestMapping("/owners/&#123;ownerId&#125;")public class OwnerController &#123; @GetMapping("/pets/&#123;petId&#125;") public Pet findPet(@PathVariable("ownerId") Long ownerId, @PathVariable Long petId) &#123; // ... &#125;&#125; URI变量会进行自动类型转换或者抛出TypeMismatchException异常，对于简单的类型，如int, long, Data，默认自动转换，对于复杂类型在此不做详解。 URI变量作为参数时，有两种声明方式： 显性声明，如上代码块： @PathVariable(&quot;ownerId&quot;)，这种声明方式明确规定使用的是URI模版里的ownerId变量。 直接使用@PathVariable，如上代码块@PathVariable Long petId，这种情况下会默认去URI模版寻找跟参数名相同的变量，但只能在使用debug模式才可以。 Request还支持正则匹配，语法格式：{varName:regex}，用regex声明了一个URI变量varName，例如： 1234@GetMapping("/&#123;name:[a-z-]+&#125;-&#123;version:\\d\\.\\d\\.\\d&#125;&#123;ext:\\.[a-z]+&#125;")public void handle(@PathVariable String version, @PathVariable String ext) &#123; // ...&#125; 2.2 Pattern comparison当有多个patterns（模版）匹配到URL时，通过AntPathMatcher.getPatternComparator(String path)去获取最合适的patterns。 对于每一个pattern，根据URI变量和通配符的个数计算出分数，分数越低优先度越高。相同分数则较长者优先度高。 默认映射模版/**不参与比较，优先度最低。 2.3 Matrix variablesMatrix variables可以出现在任意路径段，每个matrix variable由 “;” 分割，例如/cars;color=red;year=2012。多个值既可以用 “,” 分割，如color=red,green,blue，也可以重复变量名，如color=red;color=green;color=blue。 如果一个URL可能含有matrix variables，那么请求映射模版必须使用URI模版去表示。这样可以确保匹配正确，即使matrix variables的位置不固定或不存在。 如下例子，获取matrix variable “q” 12345678// GET /pets/42;q=11;r=22@GetMapping("/pets/&#123;petId&#125;")public void findPet(@PathVariable String petId, @MatrixVariable int q) &#123; // petId == 42 // q == 11&#125; 多个路径段包含matrix variables的情况： 12345678910// GET /owners/42;q=11/pets/21;q=22@GetMapping("/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;")public void findPet( @MatrixVariable(name="q", pathVar="ownerId") int q1, @MatrixVariable(name="q", pathVar="petId") int q2) &#123; // q1 == 11 // q2 == 22&#125; 可以设置matrix variable的required属性，required = false表示该参数不是必须存在的，同时可以设置defaultValue赋予默认值。如下： 1234567// GET /pets/42@GetMapping("/pets/&#123;petId&#125;")public void findPet(@MatrixVariable(required=false, defaultValue="1") int q) &#123; // q == 1&#125; 可以将所有的matrix variables放置于一个Map中： 12345678910// GET /owners/42;q=11;r=12/pets/21;q=22;s=23@GetMapping("/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;")public void findPet( @MatrixVariable MultiValueMap&lt;String, String&gt; matrixVars, @MatrixVariable(pathVar="petId"") MultiValueMap&lt;String, String&gt; petMatrixVars) &#123; // matrixVars: ["q" : [11,22], "r" : 12, "s" : 23] // petMatrixVars: ["q" : 22, "s" : 23]&#125; 最后注意：matrix variables默认是不启用的，因此我们需要在xml文件中进行配置: 12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;mvc:annotation-driven enable-matrix-variables="true"/&gt;&lt;/beans&gt; 2.4 Consumable media types利用Content-Type对请求匹配范围进行限制，从而缩小请求的映射范围。 1234@PostMapping(path = "/pets", consumes = "application/json")public void addPet(@RequestBody Pet pet) &#123; // ...&#125; consumes 属性支持否定表达，!text/plain表示除了 “text/plain” 的所有content type。 consumes可以声明在class层级，与其他request mapping attributes不同的是，当声明在class层级时，method层级的consumes属性会覆盖而不是扩展class层级的声明。 2.5 Producible media types利用Accept对请求匹配范围进行限制，从而缩小请求的映射范围。类似2.4: 12345@GetMapping(path = "/pets/&#123;petId&#125;", produces = "application/json;charset=UTF-8")@ResponseBodypublic Pet getPet(@PathVariable String petId) &#123; // ...&#125; 2.6 params, method, headers params 属性用于指定请求参数 method 属性用于限制能够访问的方法类型 //和组合注解@GetMapping等类似 headers 属性用于指定请求头信息 三者都可以缩小请求的映射范围，支持否定表达。 12345678910111213@GetMapping(path = "/pets/&#123;petId&#125;", params = "myParam=myValue")public void findPet(@PathVariable String petId) &#123; // ...&#125;@GetMapping(path = "/pets", headers = "myHeader=myValue")public void findPet1(@PathVariable String petId) &#123; // ...&#125;//和findPet1等价@RequestMapping(path = "/pets", headers = "myHeader=myValue", method = RequestMethod. GET)public void findPet2(@PathVariable String petId) &#123; // ...&#125; 3 Handler Methods3.1 Method Arguments 引用自官方文档 Controller method argument Description WebRequest, NativeWebRequest Generic access to request parameters, request &amp; session attributes, without direct use of the Servlet API. javax.servlet.ServletRequest, javax.servlet.ServletResponse Choose any specific request or response type — e.g. ServletRequest, HttpServletRequest, or Spring’s MultipartRequest, MultipartHttpServletRequest. javax.servlet.http.HttpSession Enforces the presence of a session. As a consequence, such an argument is never null.Note: Session access is not thread-safe. Consider setting theRequestMappingHandlerAdapter‘s “synchronizeOnSession” flag to “true” if multiple requests are allowed to access a session concurrently. javax.servlet.http.PushBuilder Servlet 4.0 push builder API for programmatic HTTP/2 resource pushes. Note that per Servlet spec, the injected PushBuilder instance can be null if the client does not support that HTTP/2 feature. java.security.Principal Currently authenticated user; possibly a specific Principal implementation class if known. HttpMethod The HTTP method of the request. java.util.Locale The current request locale, determined by the most specific LocaleResolver available, in effect, the configured LocaleResolver/LocaleContextResolver. Java 6+: java.util.TimeZoneJava 8+: java.time.ZoneId The time zone associated with the current request, as determined by a LocaleContextResolver. java.io.InputStream, java.io.Reader For access to the raw request body as exposed by the Servlet API. java.io.OutputStream, java.io.Writer For access to the raw response body as exposed by the Servlet API. @PathVariable For access to URI template variables. See URI patterns. @MatrixVariable For access to name-value pairs in URI path segments. See Matrix variables. @RequestParam For access to Servlet request parameters. Parameter values are converted to the declared method argument type. See @RequestParam. @RequestHeader For access to request headers. Header values are converted to the declared method argument type. See @RequestHeader. @RequestBody For access to the HTTP request body. Body content is converted to the declared method argument type using HttpMessageConverters. See @RequestBody. HttpEntity&lt;B&gt; For access to request headers and body. The body is converted with HttpMessageConverters. See HttpEntity. @RequestPart For access to a part in a “multipart/form-data” request. See @RequestPart and Multipart requests. java.util.Map, org.springframework.ui.Model, org.springframework.ui.ModelMap For access and updates of the implicit model that is exposed to the web view. RedirectAttributes Specify attributes to use in case of a redirect — i.e. to be appended to the query string, and/or flash attributes to be stored temporarily until the request after redirect. See Redirect attributes and Flash attributes. Command or form object (with optional @ModelAttribute) Command object whose properties to bind to request parameters — via setters or directly to fields, with customizable type conversion, depending on @InitBinder methods and/or the HandlerAdapter configuration (see the webBindingInitializer property onRequestMappingHandlerAdapter).Command objects along with their validation results are exposed as model attributes, by default using the command class name - e.g. model attribute “orderAddress” for a command object of type “some.package.OrderAddress”. @ModelAttribute can be used to customize the model attribute name. Errors, BindingResult Validation results for the command/form object data binding; this argument must be declared immediately after the command/form object in the controller method signature. SessionStatus For marking form processing complete which triggers cleanup of session attributes declared through a class-level @SessionAttributesannotation. UriComponentsBuilder For preparing a URL relative to the current request’s host, port, scheme, context path, and the literal part of the servlet mapping also taking into account Forwarded and X-Forwarded-* headers. @SessionAttribute For access to any session attribute; in contrast to model attributes stored in the session as a result of a class-level @SessionAttributesdeclaration. @RequestAttribute For access to request attributes. 3.2 Return Values 引用自官方文档 Controller method return value Description @ResponseBody The return value is converted through HttpMessageConverters and written to the response. See @ResponseBody. HttpEntity&lt;B&gt;, ResponseEntity&lt;B&gt; The return value specifies the full response including HTTP headers and body be converted through HttpMessageConverters and written to the response. See HttpEntity. HttpHeaders For returning a response with headers and no body. String A view name to be resolved with ViewResolver‘s and used together with the implicit model — determined through command objects and @ModelAttributemethods. The handler method may also programmatically enrich the model by declaring a Modelargument (see above). View A View instance to use for rendering together with the implicit model — determined through command objects and @ModelAttribute methods. The handler method may also programmatically enrich the model by declaring a Model argument (see above). java.util.Map, org.springframework.ui.Model Attributes to be added to the implicit model with the view name implicitly determined through a RequestToViewNameTranslator. ModelAndView object The view and model attributes to use, and optionally a response status. void A method with a void return type (or null return value) is considered to have fully handled the response if it also has a ServletResponse, or an OutputStream argument, or an @ResponseStatus annotation. The same is true also if the controller has made a positive ETag or lastModified timestamp check (see @Controller caching for details).If none of the above is true, a voidreturn type may also indicate “no response body” for REST controllers, or default view name selection for HTML controllers. Callable&lt;V&gt; Produce any of the above return values asynchronously in a Spring MVC managed thread. DeferredResult&lt;V&gt; Produce any of the above return values asynchronously from any thread — e.g. possibly as a result of some event or callback. ListenableFuture, java.util.concurrent.CompletionStage, java.util.concurrent.CompletableFuture Alternative to DeferredResult as a convenience for example when an underlying service returns one of those. ResponseBodyEmitter, SseEmitter Emit a stream of objects asynchronously to be written to the response withHttpMessageConverter‘s; also supported as the body of a ResponseEntity. StreamingResponseBody Write to the response OutputStream asynchronously; also supported as the body of aResponseEntity. Reactive types — Reactor, RxJava, or others via ReactiveAdapterRegistry Alternative to `DeferredResultwith multi-value streams (e.g. Flux, Observable) collected to a List.For streaming scenarios — .e.g. text/event-stream, application/json+stream,SseEmitter and ResponseBodyEmitter are used instead, where ServletOutputStream blocking I/O is performed on a Spring MVC managed thread and back pressure applied against the completion of each write.See Reactive return values. Any other return type A single model attribute to be added to the implicit model with the view name implicitly determined through a RequestToViewNameTranslator; the attribute name may be specified through a method-level @ModelAttribute or otherwise a name is selected based on the class name of the return type. 3.3 @RequestParam使用 @RequestParam 绑定 HttpServletRequest 请求参数到控制器方法参数： 1234567891011121314151617@Controller@RequestMapping("/pets")@SessionAttributes("pet")public class EditPetForm &#123; // ... @GetMapping public String setupForm(@RequestParam("petId") int petId, ModelMap model) &#123; Pet pet = this.clinic.loadPet(petId); model.addAttribute("pet", pet); return "petForm"; &#125; // ...&#125; 绑定的参数默认必须存在，可以通过required属性修改，如@RequestParam(name=&quot;id&quot;, required=false)。 如果控制器方法参数类型不是string，将会执行自动类型转换。 3.4 @RequestHeader使用@RequestHeader绑定绑定 HttpServletRequest 头信息到控制器方法参数。 一个request header例子: 123456Host localhost:8080Accept text/html,application/xhtml+xml,application/xml;q=0.9Accept-Language fr,en-gb;q=0.7,en;q=0.3Accept-Encoding gzip,deflateAccept-Charset ISO-8859-1,utf-8;q=0.7,*;q=0.7Keep-Alive 300 下面的例子演示了如何获取 Accept-Encoding和 Keep-Alive 的值： 12345@RequestMapping("/displayHeaderInfo.do")public void displayHeaderInfo(@RequestHeader("Accept-Encoding") String encoding, @RequestHeader("Keep-Alive") long keepAlive) &#123; //...&#125; 如果控制器方法参数类型不是string，将会执行自动类型转换。 3.5 @CookieValue使用@CookieValue绑定绑定 HttpServletRequest 的cookie信息到控制器方法参数。 假设http request中有如下cookie信息： 1JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84 下面的例子演示了如何获取JESSIONID的值： 1234@RequestMapping("/displayHeaderInfo.do")public void displayHeaderInfo(@CookieValue("JSESSIONID") String cookie) &#123; //...&#125; 3.6 @ModelAttribute//TODO]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>Controllers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[google map 比例尺算法分析]]></title>
    <url>%2F2017%2F12%2F24%2Fgoogle-map-%E6%AF%94%E4%BE%8B%E5%B0%BA%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[比例尺即地图右下角显示地图距离与实际距离比例的控件，由于Google map自带比例尺控件存在的局限性——无法调整位置和格式，所以通过此文章，介绍比例尺算法及具体实现。 什么是比例尺比例尺是表示图上距离比实地距离缩小的程度，因此也叫缩尺。用公式表示为：比例尺=图上距离/实地距离。在Google map上比例尺显示在右下角，如下图 在创建地图时只需增加设置项 1scaleControl: true 如下例 遗憾的是这样添加的比例尺会存在于右下角，而且不像其他控件一样可以调整位置。如果我们希望修改其位置或者样式，就会无从下手。 自制比例尺实现一个比例尺的关键在于如何获取到地图距离与实际距离的比例和缩放等级及维度之间的关系。google官方api未提供相关函数，因此我们需要自己计算。核心公式为 1ScaleValue = 156543.03392 * Math.cos(latLng.lat() * Math.PI / 180) / Math.pow(2, zoom) 其中zoom为当前缩放等级，latLng.lat()即目标点维度值。该公式是在地球半径为6378137m的基础上计算的，这个值即google地图所采用的值。 有了计算公式后，我们还需要一张表——缩放等级和比例尺对应表，也就是在什么样的缩放等级下使用多大的比例尺，表格如下: 12345678910111213141516171819202122232425262728Zoom Scale0 10000km1 5000km2 2000km3 1000km4 500km5 200km6 200km7 100km8 50km9 20km10 10km11 5km12 2km13 1km14 500m15 200m16 200m17 100m18 50m19 20m20 10m21 5m22 2m23 1m24 1m25 1m26 1m 通过监听地图变化事件（缩放和平移），获取当前屏幕中心点缩放等级和维度获取到scale和scalevalue，那么比例尺的长度（px） = scale/scalevalue。 获取当前比例尺长度的核心代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/** * 根据缩放等级和维度获取KM数(m数)和像素 */function setScaleInfos(zoomLevel, lat, map) &#123; // 缩放等级-比例尺 var zoomList = [&#123; text: "10000KM", value: 10000 * 1000 &#125;, &#123; text: "5000KM", value: 5000 * 1000 &#125;, &#123; text: "2000KM", value: 2000 * 1000 &#125;, &#123; text: "1000KM", value: 1000 * 1000 &#125;, &#123; text: "500KM", value: 500 * 1000 &#125;, &#123; text: "200KM", value: 200 * 1000 &#125;, &#123; text: "200KM", value: 200 * 1000 &#125;, &#123; text: "100KM", value: 100 * 1000 &#125;, &#123; text: "50KM", value: 50 * 1000 &#125;, &#123; text: "20KM", value: 20 * 1000 &#125;, &#123; text: "10KM", value: 10 * 1000 &#125;, &#123; text: "5KM", value: 5000 &#125;, &#123; text: "2KM", value: 2000 &#125;, &#123; text: "1KM", value: 1000 &#125;, &#123; text: "500m", value: 500 &#125;, &#123; text: "200m", value: 200 &#125;, &#123; text: "200m", value: 200 &#125;, &#123; text: "100m", value: 100 &#125;, &#123; text: "50m", value: 50 &#125;, &#123; text: "20m", value: 20 &#125;, &#123; text: "10m", value: 10 &#125;, &#123; text: "5m", value: 5 &#125;, &#123; text: "2m", value: 2 &#125;, &#123; text: "1m", value: 1 &#125;, &#123; text: "1m", value: 1 &#125;, &#123; text: "1m", value: 1 &#125;, &#123; text: "1m", value: 1 &#125;]; // 宽度 var pxValue = Math.floor(zoomList[zoomLevel].value / (156543.03392 * Math.cos(lat * Math.PI / 180) / Math.pow(2, zoomLevel))); // 更新经纬度数据 $W.id("scaleText").innerHTML = zoomList[zoomLevel].text; $W.id("scaleSize").style.width = pxValue + "px";&#125;; 下面是通过上述思路实现的例子，在地图右下角实现一个比例尺。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>google map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表考点剖析]]></title>
    <url>%2F2017%2F10%2F30%2F%E9%93%BE%E8%A1%A8%E8%80%83%E7%82%B9%E5%89%96%E6%9E%90%2F</url>
    <content type="text"><![CDATA[链表，最为基础的数据结构，同时也是面试中最容易出现的考察点。很多人都觉得链表如此简单，以至于在面试不断的深入考察中出现纰漏。一旦在链表上出现差错，那么也意味着你基础的羸弱，直接导致面试的失败。 在大三一年实习和后来校招的面试中，遇到了不下于五次链表的题目，题目有难有易，很难保证第一次接触能够完美的给出解答。因此总结了链表相关题目和解法，如有补充请留言。 定义全文的链表节点定义如下，无哑节点，基于C++实现。 12345struct ListNode&#123; int m_nKey; ListNode * m_pNext;&#125;; 题目求节点数目最基础的题目，直接遍历，注意循环停止条件。 12345678910111213unsigned int GetThisLength(ListNode *pHead)&#123; if (pHead == NULL) return 0; ListNode *pCurrent = pHead; unsigned int nlength = 0; while (pCurrent != NULL) &#123; nlength++; pCurrent = pCurrent-&gt;m_pNext; &#125; return nlength;&#125; 反转链表一道非常经典的面试题，简单的同时也非常容易出错，分为递归和非递归解法。 递归解法：每次递归返回的是已经反转好的链表的头结点，注意好跳出条件即可。 非递归解法：遍历链表，已遍历的部分已反转，将正在遍历的节点当做头结点连接到已反转的部分。 123456789101112131415161718192021222324252627//递归解法ListNode * ReverseList(ListNode *pHead)&#123; if (pHead == NULL || pHead-&gt;m_pNext == NULL) return pHead; ListNode *newHead = ReverseList(pHead-&gt;next); pHead-&gt;next-&gt;next = newHead-&gt;next; pHead-&gt;next = NULL; return newHead;&#125;//非递归解法ListNode * ReverseList(ListNode *pHead)&#123; if (pHead == NULL || pHead-&gt;m_pNext == NULL) return pHead; ListNode *pReverseHead = NULL; ListNode *pCurrent = pHead; while (pCurrent != NULL) &#123; ListNode *temp = pCurrent; pCurrent = pCurrent-&gt;m_pNext; temp-&gt;m_pNext = pReverseHead; pReverseHead = temp; &#125; return pReverseHead;&#125; 找倒数第k个节点双指针解题，这中思考方式在后面的题目经常出现。第一个指针先走k步，然后两个指针一起遍历，这样第一个指针到最后一个节点的时候，第二个指针即指向第k个节点。 12345678910111213141516171819ListNode * RGetKthNode(ListNode * pHead, unsigned int k)&#123; if (k == 0 || pHead == NULL) return NULL; ListNode *pAhead = pHead; ListNode *pBehind = pHead; while (pAhead != NULL&amp;&amp;k &gt; 1) &#123; pAhead = pAhead-&gt;m_pNext; k--; &#125; if (k &gt; 1 || pAhead == NULL) return NULL; while (pAhead-&gt;m_pNext != NULL) &#123; pAhead = pAhead-&gt;m_pNext; pBehind = pBehind-&gt;m_pNext; &#125;&#125; 查找中间节点无需先获取长度，只需要一次遍历即可解决问题，和上一题类似思路，两个指针，分别为“快”指针和“慢”指针。快指针每次“走两步”，慢指针每次”走一步“，这样快指针走过的节点始终是慢指针的两倍。快指针到尾节点时，返回慢指针即可。 123456789101112131415ListNode * GetMiddleNode(ListNode * pHead)&#123; if (pHead == NULL || pHead-&gt;m_pNext == NULL) return pHead; ListNode *pAhead = pHead; ListNode *pBehind = pHead; while (pAhead-&gt;m_pNext != NULL) &#123; pAhead = pAhead-&gt;m_pNext; pBehind = pBehind-&gt;m_pNext; if (pAhead-&gt;m_pNext != NULL) pAhead = pAhead-&gt;m_pNext; &#125; return pBehind;&#125; 倒序打印链表借助栈实现，遍历时将节点值存储到栈中。 1234567891011121314void PrintList(ListNode *pHead)&#123; stack&lt;ListNode *&gt; s; while (pHead != NULL) &#123; s.push(pHead); pHead = pHead-&gt;m_pNext; &#125; while (!s.empty()) &#123; cout &lt;&lt; s.top() &lt;&lt; "\t"; s.pop(); &#125;&#125; 合并两个链表遍历对比节点值，直接合并。 12345678910111213141516171819202122232425262728293031323334353637383940414243ListNode *MergeSortedLit(ListNode *pHead1, ListNode *pHead2)&#123; if (pHead1 == NULL) return pHead1; if (pHead2 == NULL) return pHead2; ListNode *pHeadMerged = NULL; if (pHead1-&gt;m_nKey &lt; pHead2-&gt;m_nKey) &#123; pHeadMerged = pHead1; //pHeadMerged-&gt;m_pNext = NULL; pHead1 = pHead1-&gt;m_pNext; &#125; else &#123; pHeadMerged = pHead2; //pHeadMerged-&gt;m_pNext = NULL; pHead2 = pHead2-&gt;m_pNext; &#125; ListNode *pTemp = pHeadMerged; while (pHead1 != NULL &amp;&amp; pHead2 != NULL) &#123; if (pHead1-&gt;m_nKey &lt; pHead2-&gt;m_nKey) &#123; pTemp-&gt;m_pNext = pHead1; pHead1 = pHead1-&gt;m_pNext; pTemp = pTemp-&gt;m_pNext; //pTemp-&gt;m_pNext = NULL; &#125; else &#123; pTemp-&gt;m_pNext = pHead2; pHead2 = pHead2-&gt;m_pNext; pTemp = pTemp-&gt;m_pNext; //pTemp-&gt;m_pNext = NULL; &#125; &#125; if (pHead1 != NULL) pTemp-&gt;m_pNext = pHead1; else if (pHead2 != NULL) pTemp-&gt;m_pNext = pHead2; return pHeadMerged;&#125; 判断单链表是否有环注意该链表有可能是首尾相接，也可能是只有后面一段是环。 经典的快慢指针解题思路，快指针每次走两步，慢指针每次走一步。如果快慢指针相遇则存在环，否则不存在环。 12345678910111213bool HasCircle(ListNode *pHead)&#123; ListNode *pFast = pHead; ListNode *pSlow = pHead; while (pFast != NULL&amp;&amp;pFast-&gt;m_pNext != NULL) &#123; pFast = pFast-&gt;m_pNext-&gt;m_pNext; pSlow = pSlow-&gt;m_pNext; if (pFast == pSlow) return true; &#125; return false;&#125; 判断两个链表是否相交如果两个链表相交，那么他们在相交点之后必定成为同一条链表，所以只需要判断两个链表的尾节点是否相同即可。 12345678910bool IsIntersected(ListNode *pHead1, ListNode *pHead2)&#123; if (pHead1 == NULL&amp;&amp;pHead2 == NULL) return false; while (pHead1-&gt;m_pNext != NULL) pHead1 = pHead1-&gt;m_pNext; while (pHead2-&gt;m_pNext != NULL) pHead2 = pHead2-&gt;m_pNext; return pHead1 == pHead2;&#125; 求两个单链表相交的第一个节点先获取两个链表的长度，然后获取长度差值len，双指针策略，较长的链表的指针先走len步，然后两个指针一起遍历，相遇即跳出，跳出点即相交的第一个节点。 1234567891011121314151617181920212223242526272829303132333435363738394041ListNode * GetFirstCommonNode(ListNode *pHead1, ListNode *pHead2)&#123; if (pHead1 == NULL || pHead2 == NULL) return NULL; int len1 = 1; ListNode *pTail1 = pHead1; while (pTail1-&gt;m_pNext != NULL) &#123; len1++; pTail1 = pTail1-&gt;m_pNext; &#125; int len2 = 1; ListNode *pTail2 = pHead2; while (pTail1-&gt;m_pNext != NULL) &#123; len2++; pTail2 = pTail2-&gt;m_pNext; &#125; if (pTail1 != pTail2) return NULL; ListNode * pNode1 = pHead1; ListNode * pNode2 = pHead2; if (len1 &gt; len2) &#123; int k = len1 - len2; while (k--) pNode1 = pNode1-&gt;m_pNext; &#125; else &#123; int k = len1 - len2; while (k--) pNode1 = pNode1-&gt;m_pNext; &#125; while (pNode1!=pNode2) &#123; pNode1 = pNode1-&gt;m_pNext; pNode2 = pNode2-&gt;m_pNext; &#125; return pNode1;&#125; 已知有环，求入环后第一个节点这题将判断链表是否有环和求两个单链表相交的第一个节点相结合，在快慢指针相遇点断开成两条新的链表，之后两个链表相交的第一个节点就是两个单链表相交的第一个节点。 参考图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051ListNode * GetFirstNodeInCycle(ListNode *pHead)&#123; if (pHead == NULL || pHead-&gt;m_pNext == NULL) return NULL; ListNode *pFast = pHead; ListNode *pSlow = pHead; while (pFast != NULL&amp;&amp;pFast-&gt;m_pNext != NULL) &#123; pFast = pFast-&gt;m_pNext-&gt;m_pNext; pSlow = pSlow-&gt;m_pNext; if (pFast == pSlow) break; &#125; if (pFast == NULL || pFast-&gt;m_pNext == NULL) return NULL; ListNode *pAssumedTail = pFast; ListNode *pHead1 = pHead; ListNode *pHead2 = pAssumedTail-&gt;m_pNext; ListNode *pNode1 = pHead1; int len1 = 1; while (pNode1 != pAssumedTail) &#123; len1++; pNode1 = pNode1-&gt;m_pNext; &#125; ListNode *pNode2 = pHead2; int len2 = 1; while (pNode2 != pAssumedTail) &#123; len2++; pNode1 = pNode2-&gt;m_pNext; &#125; if (len1 &gt; len2) &#123; int k = len1 - len2; while (k--) pNode1 = pNode1-&gt;m_pNext; &#125; else &#123; int k = len2 - len1; while (k--) pNode2 = pNode2-&gt;m_pNext; &#125; while (pNode1 != pNode2) &#123; pNode1 = pNode1-&gt;m_pNext; pNode2 = pNode2-&gt;m_pNext; &#125; return pNode1;&#125; O(1)删除一个节点一般来说删除一个节点的时间复杂度是O(n)，此处的删除是一种投机的方法，将待删除的节点的下一个节点的值赋予当前节点，然后删除下一个节点。当然如果需要删除的节点是尾节点，还是需要遍历才能删除。 12345678910111213141516171819202122232425262728293031void DeleteNode(ListNode *pHead, ListNode *pToBeDeleted)&#123; if (pToBeDeleted == NULL) return; if (pToBeDeleted-&gt;m_pNext != NULL) &#123; ListNode *pNext = pToBeDeleted-&gt;m_pNext; pToBeDeleted-&gt;m_nKey = pNext-&gt;m_nKey; pToBeDeleted-&gt;m_pNext = pNext-&gt;m_pNext; delete pNext; pNext = NULL; &#125; else &#123; if (pHead == pToBeDeleted) &#123; delete pToBeDeleted; pHead = NULL; pToBeDeleted = NULL; &#125; else &#123; ListNode *pTemp = pHead; while (pTemp-&gt;m_pNext != pToBeDeleted) pTemp = pTemp-&gt;m_pNext; delete pToBeDeleted; pTemp-&gt;m_pNext = NULL; pToBeDeleted = NULL; &#125; &#125;&#125; 考点考点多集中在双指针，快慢指针，遍历等方面。在设计链表题目时，切记要考虑空链表，遍历跳出点以及该链表是否存在哑结点。在做题前需要向面试官询问，并在代码中恰当处理，否则很容易出错。 附录全部代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;struct ListNode&#123; int m_nKey; ListNode * m_pNext;&#125;;int main()&#123; return 0;&#125;//求节点个数unsigned int GetThisLength(ListNode *pHead)&#123; if (pHead == NULL) return 0; ListNode *pCurrent = pHead; unsigned int nlength = 0; while (pCurrent != NULL) &#123; nlength++; pCurrent = pCurrent-&gt;m_pNext; &#125; return nlength;&#125;//反转链表ListNode * ReverseList(ListNode *pHead)&#123; if (pHead == NULL || pHead-&gt;m_pNext == NULL) return pHead; ListNode *pReverseHead = NULL; ListNode *pCurrent = pHead; while (pCurrent != NULL) &#123; ListNode *temp = pCurrent; pCurrent = pCurrent-&gt;m_pNext; temp-&gt;m_pNext = pReverseHead; pReverseHead = temp; &#125; return pReverseHead;&#125;ListNode * ReverseList(ListNode *pHead)&#123; if (pHead == NULL || pHead-&gt;m_pNext == NULL) return pHead; ListNode *newHead = ReverseList(pHead-&gt;next); pHead-&gt;next-&gt;next = newHead-&gt;next; pHead-&gt;next = NULL; return pReverseHead;&#125;//找倒数第k个节点ListNode * RGetKthNode(ListNode * pHead, unsigned int k)&#123; if (k == 0 || pHead == NULL) return NULL; ListNode *pAhead = pHead; ListNode *pBehind = pHead; while (pAhead != NULL&amp;&amp;k &gt; 1) &#123; pAhead = pAhead-&gt;m_pNext; k--; &#125; if (k &gt; 1 || pAhead == NULL) return NULL; while (pAhead-&gt;m_pNext != NULL) &#123; pAhead = pAhead-&gt;m_pNext; pBehind = pBehind-&gt;m_pNext; &#125;&#125;//查找中间结点ListNode * GetMiddleNode(ListNode * pHead)&#123; if (pHead == NULL || pHead-&gt;m_pNext == NULL) return pHead; ListNode *pAhead = pHead; ListNode *pBehind = pHead; while (pAhead-&gt;m_pNext != NULL) &#123; pAhead = pAhead-&gt;m_pNext; pBehind = pBehind-&gt;m_pNext; if (pAhead-&gt;m_pNext != NULL) pAhead = pAhead-&gt;m_pNext; &#125; return pBehind;&#125;//倒序打印链表void PrintList(ListNode *pHead)&#123; stack&lt;ListNode *&gt; s; while (pHead != NULL) &#123; s.push(pHead); pHead = pHead-&gt;m_pNext; &#125; while (!s.empty()) &#123; cout &lt;&lt; s.top() &lt;&lt; "\t"; s.pop(); &#125;&#125;//合并两个链表ListNode *MergeSortedLit(ListNode *pHead1, ListNode *pHead2)&#123; if (pHead1 == NULL) return pHead1; if (pHead2 == NULL) return pHead2; ListNode *pHeadMerged = NULL; if (pHead1-&gt;m_nKey &lt; pHead2-&gt;m_nKey) &#123; pHeadMerged = pHead1; //pHeadMerged-&gt;m_pNext = NULL; pHead1 = pHead1-&gt;m_pNext; &#125; else &#123; pHeadMerged = pHead2; //pHeadMerged-&gt;m_pNext = NULL; pHead2 = pHead2-&gt;m_pNext; &#125; ListNode *pTemp = pHeadMerged; while (pHead1 != NULL &amp;&amp; pHead2 != NULL) &#123; if (pHead1-&gt;m_nKey &lt; pHead2-&gt;m_nKey) &#123; pTemp-&gt;m_pNext = pHead1; pHead1 = pHead1-&gt;m_pNext; pTemp = pTemp-&gt;m_pNext; //pTemp-&gt;m_pNext = NULL; &#125; else &#123; pTemp-&gt;m_pNext = pHead2; pHead2 = pHead2-&gt;m_pNext; pTemp = pTemp-&gt;m_pNext; //pTemp-&gt;m_pNext = NULL; &#125; &#125; if (pHead1 != NULL) pTemp-&gt;m_pNext = pHead1; else if (pHead2 != NULL) pTemp-&gt;m_pNext = pHead2; return pHeadMerged;&#125;//判断单链表是否有环bool HasCircle(ListNode *pHead)&#123; ListNode *pFast = pHead; ListNode *pSlow = pHead; while (pFast != NULL&amp;&amp;pFast-&gt;m_pNext != NULL) &#123; pFast = pFast-&gt;m_pNext-&gt;m_pNext; pSlow = pSlow-&gt;m_pNext; if (pFast == pSlow) return true; &#125; return false;&#125;//判断两个链表是否相交bool IsIntersected(ListNode *pHead1, ListNode *pHead2)&#123; if (pHead1 == NULL&amp;&amp;pHead2 == NULL) return false; while (pHead1-&gt;m_pNext != NULL) pHead1 = pHead1-&gt;m_pNext; while (pHead2-&gt;m_pNext != NULL) pHead2 = pHead2-&gt;m_pNext; return pHead1 == pHead2;&#125;//求两个单链表相交的第一个节点ListNode * GetFirstCommonNode(ListNode *pHead1, ListNode *pHead2)&#123; if (pHead1 == NULL || pHead2 == NULL) return NULL; int len1 = 1; ListNode *pTail1 = pHead1; while (pTail1-&gt;m_pNext != NULL) &#123; len1++; pTail1 = pTail1-&gt;m_pNext; &#125; int len2 = 1; ListNode *pTail2 = pHead2; while (pTail1-&gt;m_pNext != NULL) &#123; len2++; pTail2 = pTail2-&gt;m_pNext; &#125; if (pTail1 != pTail2) return NULL; ListNode * pNode1 = pHead1; ListNode * pNode2 = pHead2; if (len1 &gt; len2) &#123; int k = len1 - len2; while (k--) pNode1 = pNode1-&gt;m_pNext; &#125; else &#123; int k = len1 - len2; while (k--) pNode1 = pNode1-&gt;m_pNext; &#125; while (pNode1!=pNode2) &#123; pNode1 = pNode1-&gt;m_pNext; pNode2 = pNode2-&gt;m_pNext; &#125; return pNode1;&#125;//已知有环，求入环后第一个节点ListNode * GetFirstNodeInCycle(ListNode *pHead)&#123; if (pHead == NULL || pHead-&gt;m_pNext == NULL) return NULL; ListNode *pFast = pHead; ListNode *pSlow = pHead; while (pFast != NULL&amp;&amp;pFast-&gt;m_pNext != NULL) &#123; pFast = pFast-&gt;m_pNext-&gt;m_pNext; pSlow = pSlow-&gt;m_pNext; if (pFast == pSlow) break; &#125; if (pFast == NULL || pFast-&gt;m_pNext == NULL) return NULL; ListNode *pAssumedTail = pFast; ListNode *pHead1 = pHead; ListNode *pHead2 = pAssumedTail-&gt;m_pNext; ListNode *pNode1 = pHead1; int len1 = 1; while (pNode1 != pAssumedTail) &#123; len1++; pNode1 = pNode1-&gt;m_pNext; &#125; ListNode *pNode2 = pHead2; int len2 = 1; while (pNode2 != pAssumedTail) &#123; len2++; pNode1 = pNode2-&gt;m_pNext; &#125; if (len1 &gt; len2) &#123; int k = len1 - len2; while (k--) pNode1 = pNode1-&gt;m_pNext; &#125; else &#123; int k = len2 - len1; while (k--) pNode2 = pNode2-&gt;m_pNext; &#125; while (pNode1 != pNode2) &#123; pNode1 = pNode1-&gt;m_pNext; pNode2 = pNode2-&gt;m_pNext; &#125; return pNode1;&#125;//O(1)删除一个节点void DeleteNode(ListNode *pHead, ListNode *pToBeDeleted)&#123; if (pToBeDeleted == NULL) return; if (pToBeDeleted-&gt;m_pNext != NULL) &#123; ListNode *pNext = pToBeDeleted-&gt;m_pNext; pToBeDeleted-&gt;m_nKey = pNext-&gt;m_nKey; pToBeDeleted-&gt;m_pNext = pNext-&gt;m_pNext; delete pNext; pNext = NULL; &#125; else &#123; if (pHead == pToBeDeleted) &#123; delete pToBeDeleted; pHead = NULL; pToBeDeleted = NULL; &#125; else &#123; ListNode *pTemp = pHead; while (pTemp-&gt;m_pNext != pToBeDeleted) pTemp = pTemp-&gt;m_pNext; delete pToBeDeleted; pTemp-&gt;m_pNext = NULL; pToBeDeleted = NULL; &#125; &#125;&#125;]]></content>
      <categories>
        <category>笔试面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java类与成员访问控制]]></title>
    <url>%2F2017%2F10%2F27%2Fjava%E7%B1%BB%E4%B8%8E%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[java访问控制是基础中的基础，有public/private/protected/default四个类型，一般分为类的访问控制和成员访问控制两个类型。 修饰类修饰类只能使用public和default，不可以声明为protected或private。用public修饰的类任何情况下都可以访问。用default即不加任何修饰词，权限为包访问权限，在同一个包内的类可以访问。 在修饰类的时候有以下几点需要注意 每个编译单元（文件）只能有一个public类，如果有一个以上的public类，编译器会报错 实际上类可以既不是public也可以不失default，这涉及到内部类，此处不介绍。 修饰成员 权限修饰符 同类 同包 不同包的子类 不同包的非子类 public Y Y Y Y protected Y Y Y N default Y Y N N private Y N N N 有趣的类比public：全世界共享 default：只属于中国这个国家，权限收缩protected：属于中国这个国家，当然不在中国的国人也有权使用private：只属于单一的中国人]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 双线部署及seo优化]]></title>
    <url>%2F2017%2F10%2F27%2Fhexo-%E5%8F%8C%E7%BA%BF%E9%83%A8%E7%BD%B2%E5%8F%8Aseo%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前言断断续续大概半个月，终于把个人博客搭建好，整个过程虽然简单，但是也有很多”坑“。在查询资料的过程中，阅读的博文质量参差不齐，因此想细致的写出我搭建的过程，供大家参考。文章重点在于双线部署及seo，最开始的部署和搭建将简要略过。 安装官方文档永远是最清楚正确的 https://hexo.io/zh-cn/docs/index.html 主题选择hexo的很大原因是因为其主题和插件很多，而且配置方便，这里选择的主题是大名鼎鼎的next，强烈推荐使用。next的插件配置非常便捷，而且设计符合大众审美。 配置过程详见官方文档 http://theme-next.iissnan.com/ 双线部署由于大部分人使用hexo都是将其部署在github上，省去了服务器的钱。由于“国情”原因，github的访问速度较慢，所以才有了双线部署得必要性。将国内访问流量导向coding（国内类似github的网站），国外流量导向github，从而提高访问质量。 域名申请在部署之前，我们必须申请一个域名，便宜的域名1元/年，我的域名是在阿里云买的。进入阿里云官网，点击图片中的域名注册，根据自己的需求选择想要的域名。我的域名为yinjianwen.site，在部署得时候我将博客部署在该域名的二级域名blog下，因此以后访问地址为blog.yinjianwen.site。当然你也可以直接部署在主站。 coding进入官网coding，注册账号并登录。配置好SSH公钥，这里默认你会使用git，如果不会，可以查询相关资料。 新建一个项目，名字格式为yourname.coding.me，其中yourname即为你的用户名。 选择该项目，进入代码-&gt;pages服务，绑定你之前注册的域名。 github与上述过程类似，登陆之后，点击页面右上角的加号，选择New repository，在Repository name下填写yourname.github.io，其中yourname即为你的用户名。 域名解析配置进入阿里云官网，在控制台选择域名服务，进入解析页面。然后即可进行配置。 配置的意思是，blog子域名下的世界流量（国外）访问yinxiaojian.github.io，而国内流量访问yinxiaojian.coding.me。 hexo配置最后我们需要在本地的hexo项目中进行相关配置，打开主项目下的_config.yml文件，在其中任意位置添加如下代码 12345deploy: type: git repo: github: https://github.com/yinxiaojian/yinxiaojian.github.io.git,master coding: https://coding.net/yinxiaojian/yinxiaojian.coding.me.git,master 将其中的yinxiaojian修改为你的coding和github用户名，这行代码的意思是在你通过本地deploy```指令时，会将本地hexo同步到这两个网站。1234之后需要在项目-&gt;source中添加文件CNAME，注意文件名大写且没有后缀。文件中写入你申请的域名，比如我的文件中写入的是```blog.yinjianwen.site 实际上由于github不想coding一样可以自己绑定域名，因此我们需要自己上传CNAME文件。 部署在上述操作完成后，输入以上命令，将本地项目推送到github和coding，双线部署完成。 123hexo cleanhexo generatehexo deploy]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[google map 比例尺算法分析]]></title>
    <url>%2F2017%2F12%2F24%2Fgoogle-map-%E6%AF%94%E4%BE%8B%E5%B0%BA%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[比例尺即地图右下角显示地图距离与实际距离比例的控件，由于Google map自带比例尺控件存在的局限性——无法调整位置和格式，所以通过此文章，介绍比例尺算法及具体实现。 什么是比例尺比例尺是表示图上距离比实地距离缩小的程度，因此也叫缩尺。用公式表示为：比例尺=图上距离/实地距离。在Google map上比例尺显示在右下角，如下图 在创建地图时只需增加设置项 1scaleControl: true 如下例 遗憾的是这样添加的比例尺会存在于右下角，而且不像其他控件一样可以调整位置。如果我们希望修改其位置或者样式，就会无从下手。 自制比例尺实现一个比例尺的关键在于如何获取到地图距离与实际距离的比例和缩放等级及维度之间的关系。google官方api未提供相关函数，因此我们需要自己计算。核心公式为 1ScaleValue = 156543.03392 * Math.cos(latLng.lat() * Math.PI / 180) / Math.pow(2, zoom) 其中zoom为当前缩放等级，latLng.lat()即目标点维度值。该公式是在地球半径为6378137m的基础上计算的，这个值即google地图所采用的值。 有了计算公式后，我们还需要一张表——缩放等级和比例尺对应表，也就是在什么样的缩放等级下使用多大的比例尺，表格如下: 12345678910111213141516171819202122232425262728Zoom Scale0 10000km1 5000km2 2000km3 1000km4 500km5 200km6 200km7 100km8 50km9 20km10 10km11 5km12 2km13 1km14 500m15 200m16 200m17 100m18 50m19 20m20 10m21 5m22 2m23 1m24 1m25 1m26 1m 通过监听地图变化事件（缩放和平移），获取当前屏幕中心点缩放等级和维度获取到scale和scalevalue，那么比例尺的长度（px） = scale/scalevalue。 获取当前比例尺长度的核心代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/** * 根据缩放等级和维度获取KM数(m数)和像素 */function setScaleInfos(zoomLevel, lat, map) &#123; // 缩放等级-比例尺 var zoomList = [&#123; text: "10000KM", value: 10000 * 1000 &#125;, &#123; text: "5000KM", value: 5000 * 1000 &#125;, &#123; text: "2000KM", value: 2000 * 1000 &#125;, &#123; text: "1000KM", value: 1000 * 1000 &#125;, &#123; text: "500KM", value: 500 * 1000 &#125;, &#123; text: "200KM", value: 200 * 1000 &#125;, &#123; text: "200KM", value: 200 * 1000 &#125;, &#123; text: "100KM", value: 100 * 1000 &#125;, &#123; text: "50KM", value: 50 * 1000 &#125;, &#123; text: "20KM", value: 20 * 1000 &#125;, &#123; text: "10KM", value: 10 * 1000 &#125;, &#123; text: "5KM", value: 5000 &#125;, &#123; text: "2KM", value: 2000 &#125;, &#123; text: "1KM", value: 1000 &#125;, &#123; text: "500m", value: 500 &#125;, &#123; text: "200m", value: 200 &#125;, &#123; text: "200m", value: 200 &#125;, &#123; text: "100m", value: 100 &#125;, &#123; text: "50m", value: 50 &#125;, &#123; text: "20m", value: 20 &#125;, &#123; text: "10m", value: 10 &#125;, &#123; text: "5m", value: 5 &#125;, &#123; text: "2m", value: 2 &#125;, &#123; text: "1m", value: 1 &#125;, &#123; text: "1m", value: 1 &#125;, &#123; text: "1m", value: 1 &#125;, &#123; text: "1m", value: 1 &#125;]; // 宽度 var pxValue = Math.floor(zoomList[zoomLevel].value / (156543.03392 * Math.cos(lat * Math.PI / 180) / Math.pow(2, zoomLevel))); // 更新经纬度数据 $W.id("scaleText").innerHTML = zoomList[zoomLevel].text; $W.id("scaleSize").style.width = pxValue + "px";&#125;; 下面是通过上述思路实现的例子，在地图右下角实现一个比例尺。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>google map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表考点剖析]]></title>
    <url>%2F2017%2F10%2F30%2F%E9%93%BE%E8%A1%A8%E8%80%83%E7%82%B9%E5%89%96%E6%9E%90%2F</url>
    <content type="text"><![CDATA[链表，最为基础的数据结构，同时也是面试中最容易出现的考察点。很多人都觉得链表如此简单，以至于在面试不断的深入考察中出现纰漏。一旦在链表上出现差错，那么也意味着你基础的羸弱，直接导致面试的失败。 在大三一年实习和后来校招的面试中，遇到了不下于五次链表的题目，题目有难有易，很难保证第一次接触能够完美的给出解答。因此总结了链表相关题目和解法，如有补充请留言。 定义全文的链表节点定义如下，无哑节点，基于C++实现。 12345struct ListNode&#123; int m_nKey; ListNode * m_pNext;&#125;; 题目求节点数目最基础的题目，直接遍历，注意循环停止条件。 12345678910111213unsigned int GetThisLength(ListNode *pHead)&#123; if (pHead == NULL) return 0; ListNode *pCurrent = pHead; unsigned int nlength = 0; while (pCurrent != NULL) &#123; nlength++; pCurrent = pCurrent-&gt;m_pNext; &#125; return nlength;&#125; 反转链表一道非常经典的面试题，简单的同时也非常容易出错，分为递归和非递归解法。 递归解法：每次递归返回的是已经反转好的链表的头结点，注意好跳出条件即可。 非递归解法：遍历链表，已遍历的部分已反转，将正在遍历的节点当做头结点连接到已反转的部分。 123456789101112131415161718192021222324252627//递归解法ListNode * ReverseList(ListNode *pHead)&#123; if (pHead == NULL || pHead-&gt;m_pNext == NULL) return pHead; ListNode *newHead = ReverseList(pHead-&gt;next); pHead-&gt;next-&gt;next = newHead-&gt;next; pHead-&gt;next = NULL; return newHead;&#125;//非递归解法ListNode * ReverseList(ListNode *pHead)&#123; if (pHead == NULL || pHead-&gt;m_pNext == NULL) return pHead; ListNode *pReverseHead = NULL; ListNode *pCurrent = pHead; while (pCurrent != NULL) &#123; ListNode *temp = pCurrent; pCurrent = pCurrent-&gt;m_pNext; temp-&gt;m_pNext = pReverseHead; pReverseHead = temp; &#125; return pReverseHead;&#125; 找倒数第k个节点双指针解题，这中思考方式在后面的题目经常出现。第一个指针先走k步，然后两个指针一起遍历，这样第一个指针到最后一个节点的时候，第二个指针即指向第k个节点。 12345678910111213141516171819ListNode * RGetKthNode(ListNode * pHead, unsigned int k)&#123; if (k == 0 || pHead == NULL) return NULL; ListNode *pAhead = pHead; ListNode *pBehind = pHead; while (pAhead != NULL&amp;&amp;k &gt; 1) &#123; pAhead = pAhead-&gt;m_pNext; k--; &#125; if (k &gt; 1 || pAhead == NULL) return NULL; while (pAhead-&gt;m_pNext != NULL) &#123; pAhead = pAhead-&gt;m_pNext; pBehind = pBehind-&gt;m_pNext; &#125;&#125; 查找中间节点无需先获取长度，只需要一次遍历即可解决问题，和上一题类似思路，两个指针，分别为“快”指针和“慢”指针。快指针每次“走两步”，慢指针每次”走一步“，这样快指针走过的节点始终是慢指针的两倍。快指针到尾节点时，返回慢指针即可。 123456789101112131415ListNode * GetMiddleNode(ListNode * pHead)&#123; if (pHead == NULL || pHead-&gt;m_pNext == NULL) return pHead; ListNode *pAhead = pHead; ListNode *pBehind = pHead; while (pAhead-&gt;m_pNext != NULL) &#123; pAhead = pAhead-&gt;m_pNext; pBehind = pBehind-&gt;m_pNext; if (pAhead-&gt;m_pNext != NULL) pAhead = pAhead-&gt;m_pNext; &#125; return pBehind;&#125; 倒序打印链表借助栈实现，遍历时将节点值存储到栈中。 1234567891011121314void PrintList(ListNode *pHead)&#123; stack&lt;ListNode *&gt; s; while (pHead != NULL) &#123; s.push(pHead); pHead = pHead-&gt;m_pNext; &#125; while (!s.empty()) &#123; cout &lt;&lt; s.top() &lt;&lt; "\t"; s.pop(); &#125;&#125; 合并两个链表遍历对比节点值，直接合并。 12345678910111213141516171819202122232425262728293031323334353637383940414243ListNode *MergeSortedLit(ListNode *pHead1, ListNode *pHead2)&#123; if (pHead1 == NULL) return pHead1; if (pHead2 == NULL) return pHead2; ListNode *pHeadMerged = NULL; if (pHead1-&gt;m_nKey &lt; pHead2-&gt;m_nKey) &#123; pHeadMerged = pHead1; //pHeadMerged-&gt;m_pNext = NULL; pHead1 = pHead1-&gt;m_pNext; &#125; else &#123; pHeadMerged = pHead2; //pHeadMerged-&gt;m_pNext = NULL; pHead2 = pHead2-&gt;m_pNext; &#125; ListNode *pTemp = pHeadMerged; while (pHead1 != NULL &amp;&amp; pHead2 != NULL) &#123; if (pHead1-&gt;m_nKey &lt; pHead2-&gt;m_nKey) &#123; pTemp-&gt;m_pNext = pHead1; pHead1 = pHead1-&gt;m_pNext; pTemp = pTemp-&gt;m_pNext; //pTemp-&gt;m_pNext = NULL; &#125; else &#123; pTemp-&gt;m_pNext = pHead2; pHead2 = pHead2-&gt;m_pNext; pTemp = pTemp-&gt;m_pNext; //pTemp-&gt;m_pNext = NULL; &#125; &#125; if (pHead1 != NULL) pTemp-&gt;m_pNext = pHead1; else if (pHead2 != NULL) pTemp-&gt;m_pNext = pHead2; return pHeadMerged;&#125; 判断单链表是否有环注意该链表有可能是首尾相接，也可能是只有后面一段是环。 经典的快慢指针解题思路，快指针每次走两步，慢指针每次走一步。如果快慢指针相遇则存在环，否则不存在环。 12345678910111213bool HasCircle(ListNode *pHead)&#123; ListNode *pFast = pHead; ListNode *pSlow = pHead; while (pFast != NULL&amp;&amp;pFast-&gt;m_pNext != NULL) &#123; pFast = pFast-&gt;m_pNext-&gt;m_pNext; pSlow = pSlow-&gt;m_pNext; if (pFast == pSlow) return true; &#125; return false;&#125; 判断两个链表是否相交如果两个链表相交，那么他们在相交点之后必定成为同一条链表，所以只需要判断两个链表的尾节点是否相同即可。 12345678910bool IsIntersected(ListNode *pHead1, ListNode *pHead2)&#123; if (pHead1 == NULL&amp;&amp;pHead2 == NULL) return false; while (pHead1-&gt;m_pNext != NULL) pHead1 = pHead1-&gt;m_pNext; while (pHead2-&gt;m_pNext != NULL) pHead2 = pHead2-&gt;m_pNext; return pHead1 == pHead2;&#125; 求两个单链表相交的第一个节点先获取两个链表的长度，然后获取长度差值len，双指针策略，较长的链表的指针先走len步，然后两个指针一起遍历，相遇即跳出，跳出点即相交的第一个节点。 1234567891011121314151617181920212223242526272829303132333435363738394041ListNode * GetFirstCommonNode(ListNode *pHead1, ListNode *pHead2)&#123; if (pHead1 == NULL || pHead2 == NULL) return NULL; int len1 = 1; ListNode *pTail1 = pHead1; while (pTail1-&gt;m_pNext != NULL) &#123; len1++; pTail1 = pTail1-&gt;m_pNext; &#125; int len2 = 1; ListNode *pTail2 = pHead2; while (pTail1-&gt;m_pNext != NULL) &#123; len2++; pTail2 = pTail2-&gt;m_pNext; &#125; if (pTail1 != pTail2) return NULL; ListNode * pNode1 = pHead1; ListNode * pNode2 = pHead2; if (len1 &gt; len2) &#123; int k = len1 - len2; while (k--) pNode1 = pNode1-&gt;m_pNext; &#125; else &#123; int k = len1 - len2; while (k--) pNode1 = pNode1-&gt;m_pNext; &#125; while (pNode1!=pNode2) &#123; pNode1 = pNode1-&gt;m_pNext; pNode2 = pNode2-&gt;m_pNext; &#125; return pNode1;&#125; 已知有环，求入环后第一个节点这题将判断链表是否有环和求两个单链表相交的第一个节点相结合，在快慢指针相遇点断开成两条新的链表，之后两个链表相交的第一个节点就是两个单链表相交的第一个节点。 参考图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051ListNode * GetFirstNodeInCycle(ListNode *pHead)&#123; if (pHead == NULL || pHead-&gt;m_pNext == NULL) return NULL; ListNode *pFast = pHead; ListNode *pSlow = pHead; while (pFast != NULL&amp;&amp;pFast-&gt;m_pNext != NULL) &#123; pFast = pFast-&gt;m_pNext-&gt;m_pNext; pSlow = pSlow-&gt;m_pNext; if (pFast == pSlow) break; &#125; if (pFast == NULL || pFast-&gt;m_pNext == NULL) return NULL; ListNode *pAssumedTail = pFast; ListNode *pHead1 = pHead; ListNode *pHead2 = pAssumedTail-&gt;m_pNext; ListNode *pNode1 = pHead1; int len1 = 1; while (pNode1 != pAssumedTail) &#123; len1++; pNode1 = pNode1-&gt;m_pNext; &#125; ListNode *pNode2 = pHead2; int len2 = 1; while (pNode2 != pAssumedTail) &#123; len2++; pNode1 = pNode2-&gt;m_pNext; &#125; if (len1 &gt; len2) &#123; int k = len1 - len2; while (k--) pNode1 = pNode1-&gt;m_pNext; &#125; else &#123; int k = len2 - len1; while (k--) pNode2 = pNode2-&gt;m_pNext; &#125; while (pNode1 != pNode2) &#123; pNode1 = pNode1-&gt;m_pNext; pNode2 = pNode2-&gt;m_pNext; &#125; return pNode1;&#125; O(1)删除一个节点一般来说删除一个节点的时间复杂度是O(n)，此处的删除是一种投机的方法，将待删除的节点的下一个节点的值赋予当前节点，然后删除下一个节点。当然如果需要删除的节点是尾节点，还是需要遍历才能删除。 12345678910111213141516171819202122232425262728293031void DeleteNode(ListNode *pHead, ListNode *pToBeDeleted)&#123; if (pToBeDeleted == NULL) return; if (pToBeDeleted-&gt;m_pNext != NULL) &#123; ListNode *pNext = pToBeDeleted-&gt;m_pNext; pToBeDeleted-&gt;m_nKey = pNext-&gt;m_nKey; pToBeDeleted-&gt;m_pNext = pNext-&gt;m_pNext; delete pNext; pNext = NULL; &#125; else &#123; if (pHead == pToBeDeleted) &#123; delete pToBeDeleted; pHead = NULL; pToBeDeleted = NULL; &#125; else &#123; ListNode *pTemp = pHead; while (pTemp-&gt;m_pNext != pToBeDeleted) pTemp = pTemp-&gt;m_pNext; delete pToBeDeleted; pTemp-&gt;m_pNext = NULL; pToBeDeleted = NULL; &#125; &#125;&#125; 考点考点多集中在双指针，快慢指针，遍历等方面。在设计链表题目时，切记要考虑空链表，遍历跳出点以及该链表是否存在哑结点。在做题前需要向面试官询问，并在代码中恰当处理，否则很容易出错。 附录全部代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;struct ListNode&#123; int m_nKey; ListNode * m_pNext;&#125;;int main()&#123; return 0;&#125;//求节点个数unsigned int GetThisLength(ListNode *pHead)&#123; if (pHead == NULL) return 0; ListNode *pCurrent = pHead; unsigned int nlength = 0; while (pCurrent != NULL) &#123; nlength++; pCurrent = pCurrent-&gt;m_pNext; &#125; return nlength;&#125;//反转链表ListNode * ReverseList(ListNode *pHead)&#123; if (pHead == NULL || pHead-&gt;m_pNext == NULL) return pHead; ListNode *pReverseHead = NULL; ListNode *pCurrent = pHead; while (pCurrent != NULL) &#123; ListNode *temp = pCurrent; pCurrent = pCurrent-&gt;m_pNext; temp-&gt;m_pNext = pReverseHead; pReverseHead = temp; &#125; return pReverseHead;&#125;ListNode * ReverseList(ListNode *pHead)&#123; if (pHead == NULL || pHead-&gt;m_pNext == NULL) return pHead; ListNode *newHead = ReverseList(pHead-&gt;next); pHead-&gt;next-&gt;next = newHead-&gt;next; pHead-&gt;next = NULL; return pReverseHead;&#125;//找倒数第k个节点ListNode * RGetKthNode(ListNode * pHead, unsigned int k)&#123; if (k == 0 || pHead == NULL) return NULL; ListNode *pAhead = pHead; ListNode *pBehind = pHead; while (pAhead != NULL&amp;&amp;k &gt; 1) &#123; pAhead = pAhead-&gt;m_pNext; k--; &#125; if (k &gt; 1 || pAhead == NULL) return NULL; while (pAhead-&gt;m_pNext != NULL) &#123; pAhead = pAhead-&gt;m_pNext; pBehind = pBehind-&gt;m_pNext; &#125;&#125;//查找中间结点ListNode * GetMiddleNode(ListNode * pHead)&#123; if (pHead == NULL || pHead-&gt;m_pNext == NULL) return pHead; ListNode *pAhead = pHead; ListNode *pBehind = pHead; while (pAhead-&gt;m_pNext != NULL) &#123; pAhead = pAhead-&gt;m_pNext; pBehind = pBehind-&gt;m_pNext; if (pAhead-&gt;m_pNext != NULL) pAhead = pAhead-&gt;m_pNext; &#125; return pBehind;&#125;//倒序打印链表void PrintList(ListNode *pHead)&#123; stack&lt;ListNode *&gt; s; while (pHead != NULL) &#123; s.push(pHead); pHead = pHead-&gt;m_pNext; &#125; while (!s.empty()) &#123; cout &lt;&lt; s.top() &lt;&lt; "\t"; s.pop(); &#125;&#125;//合并两个链表ListNode *MergeSortedLit(ListNode *pHead1, ListNode *pHead2)&#123; if (pHead1 == NULL) return pHead1; if (pHead2 == NULL) return pHead2; ListNode *pHeadMerged = NULL; if (pHead1-&gt;m_nKey &lt; pHead2-&gt;m_nKey) &#123; pHeadMerged = pHead1; //pHeadMerged-&gt;m_pNext = NULL; pHead1 = pHead1-&gt;m_pNext; &#125; else &#123; pHeadMerged = pHead2; //pHeadMerged-&gt;m_pNext = NULL; pHead2 = pHead2-&gt;m_pNext; &#125; ListNode *pTemp = pHeadMerged; while (pHead1 != NULL &amp;&amp; pHead2 != NULL) &#123; if (pHead1-&gt;m_nKey &lt; pHead2-&gt;m_nKey) &#123; pTemp-&gt;m_pNext = pHead1; pHead1 = pHead1-&gt;m_pNext; pTemp = pTemp-&gt;m_pNext; //pTemp-&gt;m_pNext = NULL; &#125; else &#123; pTemp-&gt;m_pNext = pHead2; pHead2 = pHead2-&gt;m_pNext; pTemp = pTemp-&gt;m_pNext; //pTemp-&gt;m_pNext = NULL; &#125; &#125; if (pHead1 != NULL) pTemp-&gt;m_pNext = pHead1; else if (pHead2 != NULL) pTemp-&gt;m_pNext = pHead2; return pHeadMerged;&#125;//判断单链表是否有环bool HasCircle(ListNode *pHead)&#123; ListNode *pFast = pHead; ListNode *pSlow = pHead; while (pFast != NULL&amp;&amp;pFast-&gt;m_pNext != NULL) &#123; pFast = pFast-&gt;m_pNext-&gt;m_pNext; pSlow = pSlow-&gt;m_pNext; if (pFast == pSlow) return true; &#125; return false;&#125;//判断两个链表是否相交bool IsIntersected(ListNode *pHead1, ListNode *pHead2)&#123; if (pHead1 == NULL&amp;&amp;pHead2 == NULL) return false; while (pHead1-&gt;m_pNext != NULL) pHead1 = pHead1-&gt;m_pNext; while (pHead2-&gt;m_pNext != NULL) pHead2 = pHead2-&gt;m_pNext; return pHead1 == pHead2;&#125;//求两个单链表相交的第一个节点ListNode * GetFirstCommonNode(ListNode *pHead1, ListNode *pHead2)&#123; if (pHead1 == NULL || pHead2 == NULL) return NULL; int len1 = 1; ListNode *pTail1 = pHead1; while (pTail1-&gt;m_pNext != NULL) &#123; len1++; pTail1 = pTail1-&gt;m_pNext; &#125; int len2 = 1; ListNode *pTail2 = pHead2; while (pTail1-&gt;m_pNext != NULL) &#123; len2++; pTail2 = pTail2-&gt;m_pNext; &#125; if (pTail1 != pTail2) return NULL; ListNode * pNode1 = pHead1; ListNode * pNode2 = pHead2; if (len1 &gt; len2) &#123; int k = len1 - len2; while (k--) pNode1 = pNode1-&gt;m_pNext; &#125; else &#123; int k = len1 - len2; while (k--) pNode1 = pNode1-&gt;m_pNext; &#125; while (pNode1!=pNode2) &#123; pNode1 = pNode1-&gt;m_pNext; pNode2 = pNode2-&gt;m_pNext; &#125; return pNode1;&#125;//已知有环，求入环后第一个节点ListNode * GetFirstNodeInCycle(ListNode *pHead)&#123; if (pHead == NULL || pHead-&gt;m_pNext == NULL) return NULL; ListNode *pFast = pHead; ListNode *pSlow = pHead; while (pFast != NULL&amp;&amp;pFast-&gt;m_pNext != NULL) &#123; pFast = pFast-&gt;m_pNext-&gt;m_pNext; pSlow = pSlow-&gt;m_pNext; if (pFast == pSlow) break; &#125; if (pFast == NULL || pFast-&gt;m_pNext == NULL) return NULL; ListNode *pAssumedTail = pFast; ListNode *pHead1 = pHead; ListNode *pHead2 = pAssumedTail-&gt;m_pNext; ListNode *pNode1 = pHead1; int len1 = 1; while (pNode1 != pAssumedTail) &#123; len1++; pNode1 = pNode1-&gt;m_pNext; &#125; ListNode *pNode2 = pHead2; int len2 = 1; while (pNode2 != pAssumedTail) &#123; len2++; pNode1 = pNode2-&gt;m_pNext; &#125; if (len1 &gt; len2) &#123; int k = len1 - len2; while (k--) pNode1 = pNode1-&gt;m_pNext; &#125; else &#123; int k = len2 - len1; while (k--) pNode2 = pNode2-&gt;m_pNext; &#125; while (pNode1 != pNode2) &#123; pNode1 = pNode1-&gt;m_pNext; pNode2 = pNode2-&gt;m_pNext; &#125; return pNode1;&#125;//O(1)删除一个节点void DeleteNode(ListNode *pHead, ListNode *pToBeDeleted)&#123; if (pToBeDeleted == NULL) return; if (pToBeDeleted-&gt;m_pNext != NULL) &#123; ListNode *pNext = pToBeDeleted-&gt;m_pNext; pToBeDeleted-&gt;m_nKey = pNext-&gt;m_nKey; pToBeDeleted-&gt;m_pNext = pNext-&gt;m_pNext; delete pNext; pNext = NULL; &#125; else &#123; if (pHead == pToBeDeleted) &#123; delete pToBeDeleted; pHead = NULL; pToBeDeleted = NULL; &#125; else &#123; ListNode *pTemp = pHead; while (pTemp-&gt;m_pNext != pToBeDeleted) pTemp = pTemp-&gt;m_pNext; delete pToBeDeleted; pTemp-&gt;m_pNext = NULL; pToBeDeleted = NULL; &#125; &#125;&#125;]]></content>
      <categories>
        <category>笔试面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java类与成员访问控制]]></title>
    <url>%2F2017%2F10%2F27%2Fjava%E7%B1%BB%E4%B8%8E%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[java访问控制是基础中的基础，有public/private/protected/default四个类型，一般分为类的访问控制和成员访问控制两个类型。 修饰类修饰类只能使用public和default，不可以声明为protected或private。用public修饰的类任何情况下都可以访问。用default即不加任何修饰词，权限为包访问权限，在同一个包内的类可以访问。 在修饰类的时候有以下几点需要注意 每个编译单元（文件）只能有一个public类，如果有一个以上的public类，编译器会报错 实际上类可以既不是public也可以不失default，这涉及到内部类，此处不介绍。 修饰成员 权限修饰符 同类 同包 不同包的子类 不同包的非子类 public Y Y Y Y protected Y Y Y N default Y Y N N private Y N N N 有趣的类比public：全世界共享 default：只属于中国这个国家，权限收缩protected：属于中国这个国家，当然不在中国的国人也有权使用private：只属于单一的中国人]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 双线部署及seo优化]]></title>
    <url>%2F2017%2F10%2F27%2Fhexo-%E5%8F%8C%E7%BA%BF%E9%83%A8%E7%BD%B2%E5%8F%8Aseo%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前言断断续续大概半个月，终于把个人博客搭建好，整个过程虽然简单，但是也有很多”坑“。在查询资料的过程中，阅读的博文质量参差不齐，因此想细致的写出我搭建的过程，供大家参考。文章重点在于双线部署及seo，最开始的部署和搭建将简要略过。 安装官方文档永远是最清楚正确的 https://hexo.io/zh-cn/docs/index.html 主题选择hexo的很大原因是因为其主题和插件很多，而且配置方便，这里选择的主题是大名鼎鼎的next，强烈推荐使用。next的插件配置非常便捷，而且设计符合大众审美。 配置过程详见官方文档 http://theme-next.iissnan.com/ 双线部署由于大部分人使用hexo都是将其部署在github上，省去了服务器的钱。由于“国情”原因，github的访问速度较慢，所以才有了双线部署得必要性。将国内访问流量导向coding（国内类似github的网站），国外流量导向github，从而提高访问质量。 域名申请在部署之前，我们必须申请一个域名，便宜的域名1元/年，我的域名是在阿里云买的。进入阿里云官网，点击图片中的域名注册，根据自己的需求选择想要的域名。我的域名为yinjianwen.site，在部署得时候我将博客部署在该域名的二级域名blog下，因此以后访问地址为blog.yinjianwen.site。当然你也可以直接部署在主站。 coding进入官网coding，注册账号并登录。配置好SSH公钥，这里默认你会使用git，如果不会，可以查询相关资料。 新建一个项目，名字格式为yourname.coding.me，其中yourname即为你的用户名。 选择该项目，进入代码-&gt;pages服务，绑定你之前注册的域名。 github与上述过程类似，登陆之后，点击页面右上角的加号，选择New repository，在Repository name下填写yourname.github.io，其中yourname即为你的用户名。 域名解析配置进入阿里云官网，在控制台选择域名服务，进入解析页面。然后即可进行配置。 配置的意思是，blog子域名下的世界流量（国外）访问yinxiaojian.github.io，而国内流量访问yinxiaojian.coding.me。 hexo配置最后我们需要在本地的hexo项目中进行相关配置，打开主项目下的_config.yml文件，在其中任意位置添加如下代码 12345deploy: type: git repo: github: https://github.com/yinxiaojian/yinxiaojian.github.io.git,master coding: https://coding.net/yinxiaojian/yinxiaojian.coding.me.git,master 将其中的yinxiaojian修改为你的coding和github用户名，这行代码的意思是在你通过本地deploy```指令时，会将本地hexo同步到这两个网站。1234之后需要在项目-&gt;source中添加文件CNAME，注意文件名大写且没有后缀。文件中写入你申请的域名，比如我的文件中写入的是```blog.yinjianwen.site 实际上由于github不想coding一样可以自己绑定域名，因此我们需要自己上传CNAME文件。 部署在上述操作完成后，输入以上命令，将本地项目推送到github和coding，双线部署完成。 123hexo cleanhexo generatehexo deploy]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>

---
title: 链表考点剖析
date: 2017-10-30 15:20:06
tags: 面试
categories: 笔试面试
---

链表，最为基础的数据结构，同时也是面试中最容易出现的考察点。很多人都觉得链表如此简单，以至于在面试不断的深入考察中出现纰漏。一旦在链表上出现差错，那么也意味着你基础的羸弱，直接导致面试的失败。

在大三一年实习和后来校招的面试中，遇到了不下于五次链表的题目，题目有难有易，很难保证第一次接触能够完美的给出解答。因此总结了链表相关题目和解法，如有补充请留言。

<!--more-->

### 定义

全文的链表节点定义如下，无哑节点，基于C++实现。

```c++
struct ListNode
{
	int m_nKey;
	ListNode * m_pNext;
};
```

### 题目

#### 求节点数目

最基础的题目，直接遍历，注意循环停止条件。

```c++
unsigned int GetThisLength(ListNode *pHead)
{
	if (pHead == NULL)
		return 0;
	ListNode *pCurrent = pHead;
	unsigned int nlength = 0;
	while (pCurrent != NULL)
	{
		nlength++;
		pCurrent = pCurrent->m_pNext;
	}
	return nlength;
}
```

#### 反转链表

一道非常经典的面试题，简单的同时也非常容易出错，分为递归和非递归解法。

递归解法：每次递归返回的是已经反转好的链表的头结点，注意好跳出条件即可。

非递归解法：遍历链表，已遍历的部分已反转，将正在遍历的节点当做头结点连接到已反转的部分。

```c++
//递归解法
ListNode * ReverseList(ListNode *pHead)
{
	if (pHead == NULL || pHead->m_pNext == NULL)
		return pHead;
	ListNode *newHead = ReverseList(pHead->next);
  	pHead->next->next = newHead->next;
  	pHead->next = NULL;
	return newHead;
}

//非递归解法
ListNode * ReverseList(ListNode *pHead)
{
	if (pHead == NULL || pHead->m_pNext == NULL)
		return pHead;
	ListNode *pReverseHead = NULL;
	ListNode *pCurrent = pHead;
	while (pCurrent != NULL)
	{
		ListNode *temp = pCurrent;
		pCurrent = pCurrent->m_pNext;
		temp->m_pNext = pReverseHead;
		pReverseHead = temp;
	}
	return pReverseHead;
}
```

#### 找倒数第k个节点

双指针解题，这中思考方式在后面的题目经常出现。第一个指针先走k步，然后两个指针一起遍历，这样第一个指针到最后一个节点的时候，第二个指针即指向第k个节点。

```c++
ListNode * RGetKthNode(ListNode * pHead, unsigned int k)
{
	if (k == 0 || pHead == NULL)
		return NULL;
	ListNode *pAhead = pHead;
	ListNode *pBehind = pHead;
	while (pAhead != NULL&&k > 1)
	{
		pAhead = pAhead->m_pNext;
		k--;
	}
	if (k > 1 || pAhead == NULL)
		return NULL;
	while (pAhead->m_pNext != NULL)
	{
		pAhead = pAhead->m_pNext;
		pBehind = pBehind->m_pNext;
	}
}
```

#### 查找中间节点

无需先获取长度，只需要一次遍历即可解决问题，和上一题类似思路，两个指针，分别为“快”指针和“慢”指针。快指针每次“走两步”，慢指针每次”走一步“，这样快指针走过的节点始终是慢指针的两倍。快指针到尾节点时，返回慢指针即可。

```C++
ListNode * GetMiddleNode(ListNode * pHead)
{
	if (pHead == NULL || pHead->m_pNext == NULL)
		return pHead;
	ListNode *pAhead = pHead;
	ListNode *pBehind = pHead;
	while (pAhead->m_pNext != NULL)
	{
		pAhead = pAhead->m_pNext;
		pBehind = pBehind->m_pNext;
		if (pAhead->m_pNext != NULL)
			pAhead = pAhead->m_pNext;
	}
	return pBehind;
}
```

#### 倒序打印链表

借助栈实现，遍历时将节点值存储到栈中。

```c++
void PrintList(ListNode *pHead)
{
	stack<ListNode *> s;
	while (pHead != NULL)
	{
		s.push(pHead);
		pHead = pHead->m_pNext;
	}
	while (!s.empty())
	{
		cout << s.top() << "\t";
		s.pop();
	}
}
```

#### 合并两个链表

遍历对比节点值，直接合并。

```c++
ListNode *MergeSortedLit(ListNode *pHead1, ListNode *pHead2)
{
	if (pHead1 == NULL)
		return pHead1;
	if (pHead2 == NULL)
		return pHead2;
	ListNode *pHeadMerged = NULL;
	if (pHead1->m_nKey < pHead2->m_nKey)
	{
		pHeadMerged = pHead1;
		//pHeadMerged->m_pNext = NULL;
		pHead1 = pHead1->m_pNext;
	}
	else
	{
		pHeadMerged = pHead2;
		//pHeadMerged->m_pNext = NULL;
		pHead2 = pHead2->m_pNext;
	}
	ListNode *pTemp = pHeadMerged;
	while (pHead1 != NULL && pHead2 != NULL)
	{
		if (pHead1->m_nKey < pHead2->m_nKey)
		{
			pTemp->m_pNext = pHead1;
			pHead1 = pHead1->m_pNext;
			pTemp = pTemp->m_pNext;
			//pTemp->m_pNext = NULL;
		}
		else
		{
			pTemp->m_pNext = pHead2;
			pHead2 = pHead2->m_pNext;
			pTemp = pTemp->m_pNext;
			//pTemp->m_pNext = NULL;
		}
	}
	if (pHead1 != NULL)
		pTemp->m_pNext = pHead1;
	else if (pHead2 != NULL)
		pTemp->m_pNext = pHead2;
	return pHeadMerged;
}
```

#### 判断单链表是否有环

注意该链表有可能是首尾相接，也可能是只有后面一段是环。

经典的快慢指针解题思路，快指针每次走两步，慢指针每次走一步。如果快慢指针相遇则存在环，否则不存在环。

```c++
bool HasCircle(ListNode *pHead)
{
	ListNode *pFast = pHead;
	ListNode *pSlow = pHead;
	while (pFast != NULL&&pFast->m_pNext != NULL)
	{
		pFast = pFast->m_pNext->m_pNext;
		pSlow = pSlow->m_pNext;
		if (pFast == pSlow)
			return true;
	}
	return false;
}
```

#### 判断两个链表是否相交

如果两个链表相交，那么他们在相交点之后必定成为同一条链表，所以只需要判断两个链表的尾节点是否相同即可。

```c++
bool IsIntersected(ListNode *pHead1, ListNode *pHead2)
{
	if (pHead1 == NULL&&pHead2 == NULL)
		return false;
	while (pHead1->m_pNext != NULL)
		pHead1 = pHead1->m_pNext;
	while (pHead2->m_pNext != NULL)
		pHead2 = pHead2->m_pNext;
	return pHead1 == pHead2;
}
```

#### 求两个单链表相交的第一个节点

先获取两个链表的长度，然后获取长度差值len，双指针策略，较长的链表的指针先走len步，然后两个指针一起遍历，相遇即跳出，跳出点即相交的第一个节点。

```c++
ListNode * GetFirstCommonNode(ListNode *pHead1, ListNode *pHead2)
{
	if (pHead1 == NULL || pHead2 == NULL)
		return NULL;
	int len1 = 1;
	ListNode *pTail1 = pHead1;
	while (pTail1->m_pNext != NULL)
	{
		len1++;
		pTail1 = pTail1->m_pNext;
	}
	int len2 = 1;
	ListNode *pTail2 = pHead2;
	while (pTail1->m_pNext != NULL)
	{
		len2++;
		pTail2 = pTail2->m_pNext;
	}
	if (pTail1 != pTail2)
		return NULL;
	ListNode * pNode1 = pHead1;
	ListNode * pNode2 = pHead2;
	if (len1 > len2)
	{
		int k = len1 - len2;
		while (k--)
			pNode1 = pNode1->m_pNext;
	}
	else
	{
		int k = len1 - len2;
		while (k--)
			pNode1 = pNode1->m_pNext;
	}
	while (pNode1!=pNode2)
	{
		pNode1 = pNode1->m_pNext;
		pNode2 = pNode2->m_pNext;
	}
	return pNode1;
}
```

#### 已知有环，求入环后第一个节点

这题将**判断链表是否有环**和**求两个单链表相交的第一个节点**相结合，在快慢指针相遇点断开成两条新的链表，之后两个链表相交的第一个节点就是两个单链表相交的第一个节点。

参考图

![](https://wx1.sinaimg.cn/large/005PPQ5Ily1g0ymxffvv3j30ir0e1q3d.jpg)

```c++
ListNode * GetFirstNodeInCycle(ListNode *pHead)
{
	if (pHead == NULL || pHead->m_pNext == NULL)
		return NULL;
	ListNode *pFast = pHead;
	ListNode *pSlow = pHead;
	while (pFast != NULL&&pFast->m_pNext != NULL)
	{
		pFast = pFast->m_pNext->m_pNext;
		pSlow = pSlow->m_pNext;
		if (pFast == pSlow)
			break;
	}
	if (pFast == NULL || pFast->m_pNext == NULL)
		return NULL;
	ListNode *pAssumedTail = pFast;
	ListNode *pHead1 = pHead;
	ListNode *pHead2 = pAssumedTail->m_pNext;
	ListNode *pNode1 = pHead1;
	int len1 = 1;
	while (pNode1 != pAssumedTail)
	{
		len1++;
		pNode1 = pNode1->m_pNext;
	}
	ListNode *pNode2 = pHead2;
	int len2 = 1;
	while (pNode2 != pAssumedTail)
	{
		len2++;
		pNode1 = pNode2->m_pNext;
	}
	if (len1 > len2)
	{
		int k = len1 - len2;
		while (k--)
			pNode1 = pNode1->m_pNext;
	}
	else
	{
		int k = len2 - len1;
		while (k--)
			pNode2 = pNode2->m_pNext;
	}
	while (pNode1 != pNode2)
	{
		pNode1 = pNode1->m_pNext;
		pNode2 = pNode2->m_pNext;
	}
	return pNode1;
}
```

#### O(1)删除一个节点

一般来说删除一个节点的时间复杂度是O(n)，此处的删除是一种投机的方法，将待删除的节点的下一个节点的值赋予当前节点，然后删除下一个节点。当然如果需要删除的节点是尾节点，还是需要遍历才能删除。

```C++
void DeleteNode(ListNode *pHead, ListNode *pToBeDeleted)
{
	if (pToBeDeleted == NULL)
		return;
	if (pToBeDeleted->m_pNext != NULL)
	{
		ListNode *pNext = pToBeDeleted->m_pNext;
		pToBeDeleted->m_nKey = pNext->m_nKey;
		pToBeDeleted->m_pNext = pNext->m_pNext;
		delete pNext;
		pNext = NULL;
	}
	else
	{
		if (pHead == pToBeDeleted)
		{
			delete pToBeDeleted;
			pHead = NULL;
			pToBeDeleted = NULL;
		}
		else
		{
			ListNode *pTemp = pHead;
			while (pTemp->m_pNext != pToBeDeleted)
				pTemp = pTemp->m_pNext;
			delete pToBeDeleted;
			pTemp->m_pNext = NULL;
			pToBeDeleted = NULL;
		}
	}
}
```

### 考点

考点多集中在双指针，快慢指针，遍历等方面。在设计链表题目时，切记要考虑空链表，遍历跳出点以及该链表是否存在哑结点。在做题前需要向面试官询问，并在代码中恰当处理，否则很容易出错。

### 附录

全部代码

```c++
#include<iostream>
#include<stack>
using namespace std;

struct ListNode
{
	int m_nKey;
	ListNode * m_pNext;
};

int main()
{
	return 0;
}

//求节点个数
unsigned int GetThisLength(ListNode *pHead)
{
	if (pHead == NULL)
		return 0;
	ListNode *pCurrent = pHead;
	unsigned int nlength = 0;
	while (pCurrent != NULL)
	{
		nlength++;
		pCurrent = pCurrent->m_pNext;
	}
	return nlength;
}

//反转链表
ListNode * ReverseList(ListNode *pHead)
{
	if (pHead == NULL || pHead->m_pNext == NULL)
		return pHead;
	ListNode *pReverseHead = NULL;
	ListNode *pCurrent = pHead;
	while (pCurrent != NULL)
	{
		ListNode *temp = pCurrent;
		pCurrent = pCurrent->m_pNext;
		temp->m_pNext = pReverseHead;
		pReverseHead = temp;
	}
	return pReverseHead;
}
ListNode * ReverseList(ListNode *pHead)
{
	if (pHead == NULL || pHead->m_pNext == NULL)
		return pHead;
	ListNode *newHead = ReverseList(pHead->next);
  	pHead->next->next = newHead->next;
  	pHead->next = NULL;
	return pReverseHead;
}

//找倒数第k个节点
ListNode * RGetKthNode(ListNode * pHead, unsigned int k)
{
	if (k == 0 || pHead == NULL)
		return NULL;
	ListNode *pAhead = pHead;
	ListNode *pBehind = pHead;
	while (pAhead != NULL&&k > 1)
	{
		pAhead = pAhead->m_pNext;
		k--;
	}
	if (k > 1 || pAhead == NULL)
		return NULL;
	while (pAhead->m_pNext != NULL)
	{
		pAhead = pAhead->m_pNext;
		pBehind = pBehind->m_pNext;
	}
}

//查找中间结点
ListNode * GetMiddleNode(ListNode * pHead)
{
	if (pHead == NULL || pHead->m_pNext == NULL)
		return pHead;
	ListNode *pAhead = pHead;
	ListNode *pBehind = pHead;
	while (pAhead->m_pNext != NULL)
	{
		pAhead = pAhead->m_pNext;
		pBehind = pBehind->m_pNext;
		if (pAhead->m_pNext != NULL)
			pAhead = pAhead->m_pNext;
	}
	return pBehind;
}

//倒序打印链表
void PrintList(ListNode *pHead)
{
	stack<ListNode *> s;
	while (pHead != NULL)
	{
		s.push(pHead);
		pHead = pHead->m_pNext;
	}
	while (!s.empty())
	{
		cout << s.top() << "\t";
		s.pop();
	}
}

//合并两个链表
ListNode *MergeSortedLit(ListNode *pHead1, ListNode *pHead2)
{
	if (pHead1 == NULL)
		return pHead1;
	if (pHead2 == NULL)
		return pHead2;
	ListNode *pHeadMerged = NULL;
	if (pHead1->m_nKey < pHead2->m_nKey)
	{
		pHeadMerged = pHead1;
		//pHeadMerged->m_pNext = NULL;
		pHead1 = pHead1->m_pNext;
	}
	else
	{
		pHeadMerged = pHead2;
		//pHeadMerged->m_pNext = NULL;
		pHead2 = pHead2->m_pNext;
	}
	ListNode *pTemp = pHeadMerged;
	while (pHead1 != NULL && pHead2 != NULL)
	{
		if (pHead1->m_nKey < pHead2->m_nKey)
		{
			pTemp->m_pNext = pHead1;
			pHead1 = pHead1->m_pNext;
			pTemp = pTemp->m_pNext;
			//pTemp->m_pNext = NULL;
		}
		else
		{
			pTemp->m_pNext = pHead2;
			pHead2 = pHead2->m_pNext;
			pTemp = pTemp->m_pNext;
			//pTemp->m_pNext = NULL;
		}
	}
	if (pHead1 != NULL)
		pTemp->m_pNext = pHead1;
	else if (pHead2 != NULL)
		pTemp->m_pNext = pHead2;
	return pHeadMerged;
}

//判断单链表是否有环
bool HasCircle(ListNode *pHead)
{
	ListNode *pFast = pHead;
	ListNode *pSlow = pHead;
	while (pFast != NULL&&pFast->m_pNext != NULL)
	{
		pFast = pFast->m_pNext->m_pNext;
		pSlow = pSlow->m_pNext;
		if (pFast == pSlow)
			return true;
	}
	return false;
}

//判断两个链表是否相交
bool IsIntersected(ListNode *pHead1, ListNode *pHead2)
{
	if (pHead1 == NULL&&pHead2 == NULL)
		return false;
	while (pHead1->m_pNext != NULL)
		pHead1 = pHead1->m_pNext;
	while (pHead2->m_pNext != NULL)
		pHead2 = pHead2->m_pNext;
	return pHead1 == pHead2;
}

//求两个单链表相交的第一个节点
ListNode * GetFirstCommonNode(ListNode *pHead1, ListNode *pHead2)
{
	if (pHead1 == NULL || pHead2 == NULL)
		return NULL;
	int len1 = 1;
	ListNode *pTail1 = pHead1;
	while (pTail1->m_pNext != NULL)
	{
		len1++;
		pTail1 = pTail1->m_pNext;
	}
	int len2 = 1;
	ListNode *pTail2 = pHead2;
	while (pTail1->m_pNext != NULL)
	{
		len2++;
		pTail2 = pTail2->m_pNext;
	}
	if (pTail1 != pTail2)
		return NULL;
	ListNode * pNode1 = pHead1;
	ListNode * pNode2 = pHead2;
	if (len1 > len2)
	{
		int k = len1 - len2;
		while (k--)
			pNode1 = pNode1->m_pNext;
	}
	else
	{
		int k = len1 - len2;
		while (k--)
			pNode1 = pNode1->m_pNext;
	}
	while (pNode1!=pNode2)
	{
		pNode1 = pNode1->m_pNext;
		pNode2 = pNode2->m_pNext;
	}
	return pNode1;
}

//已知有环，求入环后第一个节点
ListNode * GetFirstNodeInCycle(ListNode *pHead)
{
	if (pHead == NULL || pHead->m_pNext == NULL)
		return NULL;
	ListNode *pFast = pHead;
	ListNode *pSlow = pHead;
	while (pFast != NULL&&pFast->m_pNext != NULL)
	{
		pFast = pFast->m_pNext->m_pNext;
		pSlow = pSlow->m_pNext;
		if (pFast == pSlow)
			break;
	}
	if (pFast == NULL || pFast->m_pNext == NULL)
		return NULL;
	ListNode *pAssumedTail = pFast;
	ListNode *pHead1 = pHead;
	ListNode *pHead2 = pAssumedTail->m_pNext;
	ListNode *pNode1 = pHead1;
	int len1 = 1;
	while (pNode1 != pAssumedTail)
	{
		len1++;
		pNode1 = pNode1->m_pNext;
	}
	ListNode *pNode2 = pHead2;
	int len2 = 1;
	while (pNode2 != pAssumedTail)
	{
		len2++;
		pNode1 = pNode2->m_pNext;
	}
	if (len1 > len2)
	{
		int k = len1 - len2;
		while (k--)
			pNode1 = pNode1->m_pNext;
	}
	else
	{
		int k = len2 - len1;
		while (k--)
			pNode2 = pNode2->m_pNext;
	}
	while (pNode1 != pNode2)
	{
		pNode1 = pNode1->m_pNext;
		pNode2 = pNode2->m_pNext;
	}
	return pNode1;
}

//O(1)删除一个节点
void DeleteNode(ListNode *pHead, ListNode *pToBeDeleted)
{
	if (pToBeDeleted == NULL)
		return;
	if (pToBeDeleted->m_pNext != NULL)
	{
		ListNode *pNext = pToBeDeleted->m_pNext;
		pToBeDeleted->m_nKey = pNext->m_nKey;
		pToBeDeleted->m_pNext = pNext->m_pNext;
		delete pNext;
		pNext = NULL;
	}
	else
	{
		if (pHead == pToBeDeleted)
		{
			delete pToBeDeleted;
			pHead = NULL;
			pToBeDeleted = NULL;
		}
		else
		{
			ListNode *pTemp = pHead;
			while (pTemp->m_pNext != pToBeDeleted)
				pTemp = pTemp->m_pNext;
			delete pToBeDeleted;
			pTemp->m_pNext = NULL;
			pToBeDeleted = NULL;
		}
	}
}
```

